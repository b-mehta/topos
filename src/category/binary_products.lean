/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/

import category_theory.limits.shapes.binary_products
import category_theory.limits.preserves.shapes.binary_products
import category_theory.limits.shapes.pullbacks
import category_theory.comma
import category_theory.adjunction.limits
import category_theory.pempty
import category_theory.limits.preserves.basic
import category_theory.limits.preserves.shapes.products
import category.pullbacks

universes v u u' u‚ÇÇ

noncomputable theory
open category_theory category_theory.category category_theory.limits
namespace category_theory

section

variables {J K : Type v} [small_category J] [small_category K]
variables {C : Type u} [category.{v} C]

instance mono_prod_map {X Y Z W : C} (f : X ‚ü∂ Y) (g : W ‚ü∂ Z) [has_binary_products.{v} C] [mono f] [mono g] : mono (limits.prod.map f g) :=
‚ü®Œª A h k l, begin
  apply prod.hom_ext,
  { rw [‚Üê cancel_mono f, assoc, assoc, ‚Üê limits.prod.map_fst f g, reassoc_of l] },
  { rw [‚Üê cancel_mono g, assoc, assoc, ‚Üê limits.prod.map_snd f g, reassoc_of l] },
end‚ü©

variables {F : J ‚•§ C}

open category_theory.equivalence

def cone_equivalence_comp (e : K ‚âå J) (c : cone F) : cone (e.functor ‚ãô F) := cone.whisker e.functor c
def is_limit_equivalence_comp (e : K ‚âå J) {c : cone F} (t : is_limit c) : is_limit (cone.whisker e.functor c) :=
is_limit.whisker_equivalence t _

end

-- def discrete_equiv_of_iso {J : Type u} {K : Type u‚ÇÇ} (h : J ‚âÉ K) : discrete J ‚âå discrete K :=
-- { functor := discrete.functor h.to_fun,
--   inverse := functor.of_function h.inv_fun,
--   unit_iso := nat_iso.of_components (Œª X, eq_to_iso (h.left_inv X).symm) (Œª X Y f, dec_trivial),
--   counit_iso := nat_iso.of_components (Œª X, eq_to_iso (h.right_inv X)) (Œª X Y f, dec_trivial) }

-- def pempty_equiv_discrete0 : pempty ‚âå discrete (ulift (fin 0)) :=
-- begin
--   apply (functor.empty (discrete pempty)).as_equivalence.trans (discrete.equivalence _),
--   refine ‚ü®Œª x, x.elim, Œª ‚ü®t‚ü©, t.elim0, Œª t, t.elim, Œª ‚ü®t‚ü©, t.elim0‚ü©,
-- end

variables {C : Type u} [category.{v} C]

section
variables {D : Type u‚ÇÇ} [category.{v} D]

section

variables [has_finite_products.{v} C] [has_finite_products.{v} D] (F : C ‚•§ D)

@[reassoc]
lemma thingy (A B : C) [is_iso (prod_comparison F A B)] :
  inv (prod_comparison F A B) ‚â´ F.map limits.prod.fst = limits.prod.fst :=
begin
  erw (as_iso (prod_comparison F A B)).inv_comp_eq,
  dsimp [as_iso_hom, prod_comparison],
  rw prod.lift_fst,
end

@[reassoc]
lemma thingy2 (A B : C) [is_iso (prod_comparison F A B)] :
  inv (prod_comparison F A B) ‚â´ F.map limits.prod.snd = limits.prod.snd :=
begin
  erw (as_iso (prod_comparison F A B)).inv_comp_eq,
  dsimp [as_iso_hom, prod_comparison],
  rw prod.lift_snd,
end

@[reassoc] lemma prod_comparison_inv_natural {A A' B B' : C} (f : A ‚ü∂ A') (g : B ‚ü∂ B') [is_iso (prod_comparison F A B)] [is_iso (prod_comparison F A' B')] :
  inv (prod_comparison F A B) ‚â´ F.map (limits.prod.map f g) = limits.prod.map (F.map f) (F.map g) ‚â´ inv (prod_comparison F A' B') :=
begin
  erw [(as_iso (prod_comparison F A' B')).eq_comp_inv, assoc, (as_iso (prod_comparison F A B)).inv_comp_eq],
  apply prod_comparison_natural,
end

variables [preserves_limits_of_shape (discrete walking_pair) F]

end

/-- Transfer preservation of limits along a equivalence in the shape. -/
def preserves_limit_of_equiv {J‚ÇÅ J‚ÇÇ : Type v} [small_category J‚ÇÅ] [small_category J‚ÇÇ] (e : J‚ÇÅ ‚âå J‚ÇÇ)
  (F : C ‚•§ D) [preserves_limits_of_shape J‚ÇÅ F] :
  preserves_limits_of_shape J‚ÇÇ F :=
{ preserves_limit := Œª K,
  begin
    refine ‚ü®Œª c t, _‚ü©,
    have : is_limit (F.map_cone (cone.whisker e.functor c)),
      apply is_limit_of_preserves F (is_limit.whisker_equivalence t e),
    have := is_limit.whisker_equivalence this e.symm,
    let equ := e.inv_fun_id_assoc (K ‚ãô F),
    apply ((is_limit.postcompose_hom_equiv equ _).symm this).of_iso_limit,
    apply cones.ext _ _,
    { apply iso.refl _ },
    { intro j,
      dsimp,
      simp [‚Üêfunctor.map_comp] },
  end }

@[simps {rhs_md := semireducible}]
def build_prod {n : ‚Ñï} {f : ulift (fin (n+1)) ‚Üí C}
  (c‚ÇÅ : fan (Œª (i : ulift (fin n)), f ‚ü®i.down.succ‚ü©))
  (c‚ÇÇ : binary_fan (f ‚ü®0‚ü©) c‚ÇÅ.X) :
fan f :=
fan.mk c‚ÇÇ.X
begin
  rintro ‚ü®i‚ü©,
  revert i,
  refine fin.cases _ _,
  { apply c‚ÇÇ.fst },
  { intro i,
    apply c‚ÇÇ.snd ‚â´ c‚ÇÅ.œÄ.app (ulift.up i) },
end

def build_limit {n : ‚Ñï} (f : ulift (fin (n+1)) ‚Üí C)
  {c‚ÇÅ : fan (Œª (i : ulift (fin n)), f ‚ü®i.down.succ‚ü©)} {c‚ÇÇ : binary_fan (f ‚ü®0‚ü©) c‚ÇÅ.X}
  (t‚ÇÅ : is_limit c‚ÇÅ) (t‚ÇÇ : is_limit c‚ÇÇ) :
  is_limit (build_prod c‚ÇÅ c‚ÇÇ) :=
{ lift := Œª s,
  begin
    apply (binary_fan.is_limit.lift' t‚ÇÇ _ _).1,
    { apply s.œÄ.app ‚ü®0‚ü© },
    { apply t‚ÇÅ.lift ‚ü®_, discrete.nat_trans (Œª i, s.œÄ.app ‚ü®i.down.succ‚ü©)‚ü© }
  end,
  fac' := Œª s,
  begin
    rintro ‚ü®j‚ü©,
    revert j,
    rw fin.forall_fin_succ,
    split,
    { apply (binary_fan.is_limit.lift' t‚ÇÇ _ _).2.1 },
    { intro i,
      dsimp only [build_prod_œÄ_app],
      rw [fin.cases_succ, ‚Üê assoc, (binary_fan.is_limit.lift' t‚ÇÇ _ _).2.2, t‚ÇÅ.fac],
      refl }
  end,
  uniq' := Œª s m w,
  begin
    apply binary_fan.is_limit.hom_ext t‚ÇÇ,
    { rw (binary_fan.is_limit.lift' t‚ÇÇ _ _).2.1,
      apply w ‚ü®0‚ü© },
    { rw (binary_fan.is_limit.lift' t‚ÇÇ _ _).2.2,
      apply t‚ÇÅ.uniq ‚ü®_, _‚ü©,
      rintro ‚ü®j‚ü©,
      rw assoc,
      dsimp only [discrete.nat_trans_app],
      rw ‚Üê w ‚ü®j.succ‚ü©,
      dsimp only [build_prod_œÄ_app],
      rw fin.cases_succ }
  end }

variables (F : C ‚•§ D) [preserves_limits_of_shape (discrete walking_pair) F] [preserves_limits_of_shape (discrete pempty) F]
variables [has_finite_products.{v} C] [has_finite_products.{v} D]

def fin0_equiv_pempty : fin 0 ‚âÉ pempty :=
equiv.equiv_pempty (Œª a, a.elim0)

lemma has_scalar.ext {R M : Type*} : ‚àÄ (a b : has_scalar R M), a.smul = b.smul ‚Üí a = b
| ‚ü®_‚ü© ‚ü®_‚ü© rfl := rfl

noncomputable def preserves_fin_of_preserves_binary_and_terminal  :
  Œ† (n : ‚Ñï) (f : ulift (fin n) ‚Üí C), preserves_limit (discrete.functor f) F
| 0 := Œª f,
  begin
    letI : preserves_limits_of_shape (discrete (ulift (fin 0))) F :=
      preserves_limit_of_equiv (discrete.equivalence (equiv.ulift.trans fin0_equiv_pempty).symm) _,
    apply_instance,
  end
| (n+1) :=
  begin
    haveI := preserves_fin_of_preserves_binary_and_terminal n,
    intro f,
    refine preserves_limit_of_preserves_limit_cone
      (build_limit f (limit.is_limit _) (limit.is_limit _)) _,
    apply (is_limit_map_cone_fan_mk_equiv _ _ _).symm _,
    let := build_limit (Œª i, F.obj (f i))
              (is_limit_of_has_product_of_preserves_limit F _)
              (is_limit_of_has_binary_product_of_preserves_limit F _ _),
    refine is_limit.of_iso_limit this _,
    apply cones.ext _ _,
    apply iso.refl _,
    rintro ‚ü®j‚ü©,
    revert j,
    refine fin.cases _ _,
    { symmetry,
      apply category.id_comp _ },
    { intro i,
      symmetry,
      dsimp,
      rw [fin.cases_succ, fin.cases_succ],
      change ùüô _ ‚â´ F.map _ = F.map _ ‚â´ F.map _,
      rw [id_comp, ‚Üê F.map_comp],
      refl }
  end

def preserves_ulift_fin_of_preserves_binary_and_terminal (n : ‚Ñï) :
  preserves_limits_of_shape (discrete (ulift (fin n))) F :=
{ preserves_limit := Œª K,
  begin
    let : discrete.functor K.obj ‚âÖ K := discrete.nat_iso (Œª i, iso.refl _),
    haveI := preserves_fin_of_preserves_binary_and_terminal F n K.obj,
    apply preserves_limit_of_iso_diagram F this,
  end }

def preserves_finite_products_of_preserves_binary_and_terminal (J : Type v) [fintype J] :
  preserves_limits_of_shape.{v} (discrete J) F :=
begin
  classical,
  refine trunc.rec_on_subsingleton (fintype.equiv_fin J) _,
  intro e,
  haveI := preserves_ulift_fin_of_preserves_binary_and_terminal F (fintype.card J),
  apply preserves_limit_of_equiv (discrete.equivalence (e.trans equiv.ulift.symm)).symm,
end

end

variables [has_binary_products.{v} C] {B : C} [has_binary_products.{v} (over B)]
variables (f g : over B)

@[reducible]
def magic_arrow (f g : over B) :
  (g ‚®Ø f).left ‚ü∂ g.left ‚®Ø f.left :=
prod.lift ((limits.prod.fst : g ‚®Ø f ‚ü∂ g).left) ((limits.prod.snd : g ‚®Ø f ‚ü∂ f).left)

-- This is an equalizer but we don't really need that
instance magic_mono : mono (magic_arrow f g) :=
begin
  refine ‚ü®Œª Z p q h, _‚ü©,
  have h‚ÇÅ := h =‚â´ limits.prod.fst,
  rw [assoc, assoc, prod.lift_fst] at h‚ÇÅ,
  have h‚ÇÇ := h =‚â´ limits.prod.snd,
  rw [assoc, assoc, prod.lift_snd] at h‚ÇÇ,
  have: p ‚â´ (g ‚®Ø f).hom = q ‚â´ (g ‚®Ø f).hom,
    have: (g ‚®Ø f).hom = (limits.prod.fst : g ‚®Ø f ‚ü∂ g).left ‚â´ g.hom := (over.w (limits.prod.fst : g ‚®Ø f ‚ü∂ g)).symm,
    rw this,
    apply reassoc_of h‚ÇÅ,
  let Z' : over B := over.mk (q ‚â´ (g ‚®Ø f).hom),
  let p' : Z' ‚ü∂ g ‚®Ø f := over.hom_mk p,
  let q' : Z' ‚ü∂ g ‚®Ø f := over.hom_mk q,
  suffices: p' = q',
    show p'.left = q'.left,
    rw this,
  apply prod.hom_ext,
  ext1,
  exact h‚ÇÅ,
  ext1,
  exact h‚ÇÇ,
end

def magic_comm (f g h : over B) (k : f ‚ü∂ g) :
  (limits.prod.map k (ùüô h)).left ‚â´ magic_arrow h g = magic_arrow h f ‚â´ limits.prod.map k.left (ùüô h.left) :=
begin
  apply prod.hom_ext,
  { rw [assoc, prod.lift_fst, ‚Üê over.comp_left, limits.prod.map_fst, assoc, limits.prod.map_fst, prod.lift_fst_assoc], refl },
  { rw [assoc, assoc, limits.prod.map_snd, comp_id, prod.lift_snd, ‚Üê over.comp_left, limits.prod.map_snd, comp_id, prod.lift_snd] }
end
def magic_pb (f g h : over B) (k : f ‚ü∂ g) :
  is_limit (pullback_cone.mk (limits.prod.map k (ùüô h)).left (magic_arrow h f) (magic_comm f g h k)) :=
begin
  refine is_limit.mk' _ _,
  intro s,
  have s‚ÇÅ := pullback_cone.condition s =‚â´ limits.prod.fst,
    rw [assoc, assoc, prod.lift_fst, limits.prod.map_fst] at s‚ÇÅ,
  have s‚ÇÇ := pullback_cone.condition s =‚â´ limits.prod.snd,
    rw [assoc, assoc, prod.lift_snd, limits.prod.map_snd, comp_id] at s‚ÇÇ,
  let sX' : over B := over.mk (pullback_cone.fst s ‚â´ (g ‚®Ø h).hom),
  have z : (pullback_cone.snd s ‚â´ limits.prod.snd) ‚â´ h.hom = sX'.hom,
    rw ‚Üê s‚ÇÇ,
    change (pullback_cone.fst s ‚â´ _) ‚â´ h.hom = pullback_cone.fst s ‚â´ (g ‚®Ø h).hom,
    rw ‚Üê over.w (limits.prod.snd : g ‚®Ø h ‚ü∂ _),
    rw assoc,
  have z‚ÇÇ : (pullback_cone.snd s ‚â´ limits.prod.fst) ‚â´ f.hom = pullback_cone.fst s ‚â´ (g ‚®Ø h).hom,
    rw ‚Üê over.w k,
    slice_lhs 1 3 {rw ‚Üê s‚ÇÅ},
    rw assoc,
    rw over.w (limits.prod.fst : g ‚®Ø h ‚ü∂ _),
  let l : sX' ‚ü∂ f := over.hom_mk (pullback_cone.snd s ‚â´ limits.prod.fst) z‚ÇÇ,
  let t : sX' ‚ü∂ f ‚®Ø h := prod.lift l (over.hom_mk (pullback_cone.snd s ‚â´ limits.prod.snd) z),
  have t‚ÇÅ: t.left ‚â´ (limits.prod.fst : f ‚®Ø h ‚ü∂ f).left = l.left,
    rw [‚Üê over.comp_left, prod.lift_fst],
  have t‚ÇÇ: t.left ‚â´ (limits.prod.snd : f ‚®Ø h ‚ü∂ h).left = pullback_cone.snd s ‚â´ limits.prod.snd,
    rw [‚Üê over.comp_left, prod.lift_snd], refl,
  have fac: t.left ‚â´ magic_arrow h f = pullback_cone.snd s,
    apply prod.hom_ext,
    rw [assoc],
    change t.left ‚â´ magic_arrow h f ‚â´ limits.prod.fst = pullback_cone.snd s ‚â´ limits.prod.fst,
    rw [prod.lift_fst], exact t‚ÇÅ,
    rw ‚Üê t‚ÇÇ,
    rw assoc,
    change t.left ‚â´ magic_arrow h f ‚â´ limits.prod.snd = _,
    rw prod.lift_snd,
  refine ‚ü®t.left, _, fac, _‚ü©,
  rw [‚Üê cancel_mono (magic_arrow h g), pullback_cone.condition s, assoc],
  change t.left ‚â´ (limits.prod.map k (ùüô h)).left ‚â´ magic_arrow h g =
    pullback_cone.snd s ‚â´ limits.prod.map k.left (ùüô h.left),
  rw [magic_comm, ‚Üê fac, assoc],
  intros m m‚ÇÅ m‚ÇÇ,
  rw ‚Üê cancel_mono (magic_arrow h f),
  erw m‚ÇÇ,
  exact fac.symm,
end

end category_theory