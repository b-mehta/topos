/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/

import category_theory.limits.shapes
import category_theory.limits.shapes.binary_products
import category_theory.limits.shapes.finite_products
import category_theory.limits.shapes.finite_limits
import category_theory.limits.types
import category_theory.adjunction.limits
import category_theory.monad.limits
import category_theory.limits.opposites
import category_theory.limits.over
import category_theory.epi_mono
import category_theory.limits.shapes.equalizers
import category_theory.limits.shapes.constructions.limits_of_products_and_equalizers
import category_theory.limits.shapes.constructions.preserve_binary_products
import category.adjoint_lifting
import locally_cartesian_closed
import subobject_classifier

/-!
# Power objects

Define power objects.
Show that power objects induce a (contravariant) functor `P_functor`.
Show that this is self-adjoint on the right.
Define the singleton arrow {} : B ‚ü∂ PB and internal image (for monos only)
and show the latter is functorial too.
Show the existence of a subobject classifier given power objects and show

-/
universes v u v‚ÇÇ u‚ÇÇ

namespace category_theory

open category_theory category limits

attribute [instance] has_finite_wide_pullbacks_of_has_finite_limits

variables {C : Type u} [category.{v} C]

variables [has_finite_limits.{v} C]

abbreviation powerises {A PA niA B R : C} (memA : niA ‚ü∂ PA ‚®Ø A) (m : R ‚ü∂ B ‚®Ø A) (mhat : B ‚ü∂ PA) :=
has_pullback_top m (limits.prod.map mhat (ùüô A)) memA

instance subsingleton_powerises {A PA niA B R : C} (memA : niA ‚ü∂ PA ‚®Ø A) [mono memA] (m : R ‚ü∂ B ‚®Ø A) (mhat : B ‚ü∂ PA) :
  subsingleton (powerises memA m mhat) :=
‚ü®by { intros P Q, cases P, cases Q, congr, rw [‚Üê cancel_mono memA, P_comm, Q_comm] }‚ü©

structure is_power_object {A PA niA : C} (memA : niA ‚ü∂ PA ‚®Ø A) :=
(hat : ‚àÄ {B R} (m : R ‚ü∂ B ‚®Ø A) [mono.{v} m], B ‚ü∂ PA)
(powerises' : ‚àÄ {B R} (m : R ‚ü∂ B ‚®Ø A) [hm : mono m], powerises memA m (hat m))
(uniquely' : ‚àÄ {B R} {m : R ‚ü∂ B ‚®Ø A} [hm : mono m] {hat' : B ‚ü∂ PA}, powerises memA m hat' ‚Üí hat m = hat')

class has_power_object (A : C) :=
(PA niA : C)
(memA : niA ‚ü∂ PA ‚®Ø A)
[is_mono : mono memA]
(is_power : is_power_object memA)

attribute [instance] has_power_object.is_mono

variable (C)

class has_power_objects :=
(has_power_object : Œ† (A : C), has_power_object.{v} A)

variable {C}

attribute [instance, priority 990] has_power_objects.has_power_object
attribute [simp] pullback.condition

section convenience

variables (A : C) [has_power_object.{v} A]

def P : C := has_power_object.PA.{v} A
def ni : C := has_power_object.niA.{v} A
def mem : ni A ‚ü∂ P A ‚®Ø A := has_power_object.memA
def power_is_power : is_power_object (mem A) := has_power_object.is_power
instance mono_mem : mono (mem A) := has_power_object.is_mono

def mem_sub : sub (P A ‚®Ø A) := sub.mk' (mem A)
def mem_subq : subq (P A ‚®Ø A) := ‚ü¶mem_sub A‚üß

variables {A} {B R : C} (m : R ‚ü∂ B ‚®Ø A) [mono m]

def hat : B ‚ü∂ P A := (power_is_power A).hat m
def hat_powerises : powerises (mem A) m (hat m) := (power_is_power A).powerises' m

variable {m}
lemma unique_hat {hat' : B ‚ü∂ P A} (hp : powerises (mem A) m hat') : hat m = hat' := (power_is_power A).uniquely' hp
end convenience

lemma P_unique_aux {A : C} {PA‚ÇÅ niA‚ÇÅ PA‚ÇÇ niA‚ÇÇ : C}
  (memA‚ÇÅ : niA‚ÇÅ ‚ü∂ PA‚ÇÅ ‚®Ø A) (memA‚ÇÇ : niA‚ÇÇ ‚ü∂ PA‚ÇÇ ‚®Ø A) [mono memA‚ÇÅ] [mono memA‚ÇÇ]
  (h‚ÇÅ : is_power_object memA‚ÇÅ) (h‚ÇÇ : is_power_object memA‚ÇÇ) :
h‚ÇÅ.hat memA‚ÇÇ ‚â´ h‚ÇÇ.hat memA‚ÇÅ = ùüô PA‚ÇÇ :=
begin
  have: h‚ÇÇ.hat memA‚ÇÇ = ùüô _,
  { apply h‚ÇÇ.uniquely',
    change has_pullback_top _ _ _,
    rw prod_map_id_id,
    apply top_iso_has_pullback_top (ùüô _),
    rw [id_comp, comp_id] },
  rw ‚Üê this,
  symmetry,
  apply h‚ÇÇ.uniquely',
  change has_pullback_top _ _ _,
  rw prod_map_comp_id,
  apply left_right_hpb_to_both_hpb _ (h‚ÇÅ.powerises' memA‚ÇÇ) (h‚ÇÇ.powerises' memA‚ÇÅ),
end

def P_unique_up_to_iso {A : C} {PA‚ÇÅ niA‚ÇÅ PA‚ÇÇ niA‚ÇÇ : C}
  {memA‚ÇÅ : niA‚ÇÅ ‚ü∂ PA‚ÇÅ ‚®Ø A} {memA‚ÇÇ : niA‚ÇÇ ‚ü∂ PA‚ÇÇ ‚®Ø A} [mono memA‚ÇÅ] [mono memA‚ÇÇ]
  (h‚ÇÅ : is_power_object memA‚ÇÅ) (h‚ÇÇ : is_power_object memA‚ÇÇ) :
PA‚ÇÅ ‚âÖ PA‚ÇÇ :=
{ hom := h‚ÇÇ.hat memA‚ÇÅ,
  inv := h‚ÇÅ.hat memA‚ÇÇ,
  hom_inv_id' := P_unique_aux memA‚ÇÇ memA‚ÇÅ h‚ÇÇ h‚ÇÅ,
  inv_hom_id' := P_unique_aux memA‚ÇÅ memA‚ÇÇ h‚ÇÅ h‚ÇÇ }

variables {A B : C} [has_power_object.{v} A]

lemma hat_lift_of_is_iso {B R‚ÇÅ R‚ÇÇ : C} {g‚ÇÅ : R‚ÇÅ ‚ü∂ B ‚®Ø A} {g‚ÇÇ : R‚ÇÇ ‚ü∂ B ‚®Ø A} [mono g‚ÇÅ] [mono g‚ÇÇ] (hom : R‚ÇÅ ‚ü∂ R‚ÇÇ) [is_iso hom] (k : hom ‚â´ g‚ÇÇ = g‚ÇÅ) :
  hat g‚ÇÅ = hat g‚ÇÇ :=
begin
  apply unique_hat,
  change has_pullback_top _ _ _,
  rw [‚Üê id_comp (limits.prod.map _ _)],
  refine left_right_hpb_to_both_hpb g‚ÇÇ (top_iso_has_pullback_top hom _ _ _ (by simp [k])) (hat_powerises g‚ÇÇ),
end

lemma hat_lift_of_iso {B R‚ÇÅ R‚ÇÇ : C} {g‚ÇÅ : R‚ÇÅ ‚ü∂ B ‚®Ø A} {g‚ÇÇ : R‚ÇÇ ‚ü∂ B ‚®Ø A} [mono g‚ÇÅ] [mono g‚ÇÇ] (h : R‚ÇÅ ‚âÖ R‚ÇÇ) (k : h.hom ‚â´ g‚ÇÇ = g‚ÇÅ) :
  hat g‚ÇÅ = hat g‚ÇÇ :=
hat_lift_of_is_iso h.hom k

-- We need to assume g‚ÇÅ = hom ‚â´ g‚ÇÇ. From here if we know that hom,inv cancel then we get g‚ÇÇ = inv ‚â´ g‚ÇÅ.
-- Instead we assume this and derive that hom,inv cancel
lemma lifting {A B R‚ÇÅ R‚ÇÇ : C} [has_power_object.{v} A] {g‚ÇÅ : R‚ÇÅ ‚ü∂ B ‚®Ø A} {g‚ÇÇ : R‚ÇÇ ‚ü∂ B ‚®Ø A} [mono g‚ÇÅ] [mono g‚ÇÇ] (hom : R‚ÇÅ ‚ü∂ R‚ÇÇ) (inv : R‚ÇÇ ‚ü∂ R‚ÇÅ) :
  hom ‚â´ g‚ÇÇ = g‚ÇÅ ‚Üí inv ‚â´ g‚ÇÅ = g‚ÇÇ ‚Üí hat g‚ÇÅ = hat g‚ÇÇ :=
begin
  intros k l,
  apply hat_lift_of_iso ‚ü®hom, inv, _, _‚ü© k;
  simp [‚Üê cancel_mono g‚ÇÅ, ‚Üê cancel_mono g‚ÇÇ, l, k],
end

lemma liftable {B : C} (a b : sub (B ‚®Ø A)) (i : a ‚âà b) : hat a.arrow = hat b.arrow :=
nonempty.elim i (Œª i, lifting _ _ (sub.w i.hom) (sub.w i.inv))

def get_named_object {B : C} (k : B ‚ü∂ P A) : C := pullback (mem A) (limits.prod.map k (ùüô _))
def get_named_arrow {B : C} (k : B ‚ü∂ P A) : get_named_object k ‚ü∂ B ‚®Ø A := pullback.snd
instance get_named_mono {B : C} (k : B ‚ü∂ P A) : mono (get_named_arrow k) := pullback.snd_of_mono
lemma hat_get_named_arrow {B : C} (k : B ‚ü∂ P A) : hat (get_named_arrow k) = k :=
unique_hat has_pullback_top_of_pb

def hat_natural_left {B B' R : C} (k : R ‚ü∂ B ‚®Ø A) [mono k] (g : B' ‚ü∂ B) :
  hat (pullback.snd : pullback k (limits.prod.map g (ùüô A)) ‚ü∂ B' ‚®Ø A) = g ‚â´ hat k :=
begin
  apply unique_hat,
  change has_pullback_top _ _ _,
  rw prod_map_comp_id,
  apply left_right_hpb_to_both_hpb _ has_pullback_top_of_pb (hat_powerises k),
end

@[simps]
def name_bijection {A B : C} [has_power_object.{v} A] : (B ‚ü∂ P A) ‚âÉ subq (B ‚®Ø A) :=
{ to_fun := Œª k, ‚ü¶sub.mk' (get_named_arrow k)‚üß,
  inv_fun := quotient.lift (Œª (f : sub (B ‚®Ø A)), hat f.arrow) liftable,
  left_inv := hat_get_named_arrow,
  right_inv := quotient.ind
  begin
    intro g,
    apply quotient.sound,
    exact equiv_of_both_ways
      (sub.hom_mk _ ((hat_powerises g.arrow).is_pb.fac _ walking_cospan.right))
      (sub.hom_mk _ (pullback.lift_snd _ _ (hat_powerises g.arrow).comm)),
  end }

abbreviation name_subobject {B : C} : subq (B ‚®Ø A) ‚Üí (B ‚ü∂ P A) := name_bijection.symm

lemma get_named_subobject_eq_pullback_mem {B : C} (k : B ‚ü∂ P A) :
  name_bijection k = (subq.pullback (limits.prod.map k (ùüô _))).obj (mem_subq A) := rfl

def get_named_subobject_natural_left {B B' : C} (k : B ‚ü∂ P A) (g : B' ‚ü∂ B) :
  name_bijection (g ‚â´ k) = (subq.pullback (limits.prod.map g (ùüô A))).obj (name_bijection k) :=
by { rw [get_named_subobject_eq_pullback_mem, prod_map_comp_id, subq.pullback_comp], refl }

lemma name_pullback {B' : C} (g : subq (B ‚®Ø A)) (f : B' ‚ü∂ B) :
  name_subobject ((subq.pullback (limits.prod.map f (ùüô _))).obj g) = f ‚â´ name_subobject g :=
quotient.induction_on g (Œª a, hat_natural_left a.arrow _)

lemma pullback_along_hat_eq_self {R : C} (m : R ‚ü∂ B ‚®Ø A) [mono m] :
  (subq.pullback (limits.prod.map (hat m) (ùüô A))).obj (mem_subq A) = ‚ü¶sub.mk' m‚üß :=
begin
  rw ‚Üê get_named_subobject_eq_pullback_mem,
  erw name_bijection.apply_eq_iff_eq_symm_apply,
  refl
end

section functor_setup

variables (f : A ‚ü∂ B) [has_power_object.{v} B]
def E : C := pullback (mem B) (limits.prod.map (ùüô _) f)
def Emap : E f ‚ü∂ P B ‚®Ø A := pullback.snd
instance Emap_mono : mono (Emap f) := pullback.snd_of_mono
def Esubq : subq (P B ‚®Ø A) := (subq.pullback (limits.prod.map (ùüô _) f)).obj (mem_subq B)
lemma Esquare : (pullback.fst : E f ‚ü∂ _) ‚â´ mem B = Emap f ‚â´ limits.prod.map (ùüô _) f := pullback.condition
lemma Epb : is_limit (pullback_cone.mk _ _ (Esquare f)) :=
cone_is_pullback _ _

variable [has_power_object.{v} A]
def P_map : P B ‚ü∂ P A :=
name_subobject (Esubq f)

lemma hat_natural_right {D R : C} (m : R ‚ü∂ D ‚®Ø B) [hm : mono m] :
  hat (pullback.snd : pullback m (limits.prod.map (ùüô D) f) ‚ü∂ D ‚®Ø A) = hat m ‚â´ P_map f :=
begin
  apply unique_hat,
  change has_pullback_top _ _ _,
  rw prod_map_comp_id,
  apply left_right_hpb_to_both_hpb _ _ (hat_powerises _),
  apply right_both_hpb_to_left_hpb _ _ _ has_pullback_top_of_pb,
  rw ‚Üê prod_map_map,
  apply left_right_hpb_to_both_hpb m has_pullback_top_of_pb (hat_powerises _),
end

lemma name_other_pullback {D : C} :
  ‚àÄ m, name_subobject ((subq.pullback (limits.prod.map (ùüô D) f)).obj m) = name_subobject m ‚â´ P_map f :=
quotient.ind (by { intro a, apply hat_natural_right })

@[simp] lemma lift'_right {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {t : pullback_cone f g} (ht : is_limit t) {W : C} (h : W ‚ü∂ X) (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) :
  (pullback_cone.is_limit.lift' ht h k w).val ‚â´ t.snd = k :=
(pullback_cone.is_limit.lift' ht h k w).2.2

def how_inj_is_hat {B R‚ÇÅ R‚ÇÇ : C} {f‚ÇÅ : R‚ÇÅ ‚ü∂ B ‚®Ø A} {f‚ÇÇ : R‚ÇÇ ‚ü∂ B ‚®Ø A} [mono f‚ÇÅ] [mono f‚ÇÇ] (h : hat f‚ÇÅ = hat f‚ÇÇ) :
  R‚ÇÅ ‚âÖ R‚ÇÇ :=
{ hom := (pullback_cone.is_limit.lift' (hat_powerises f‚ÇÇ).is_pb (hat_powerises f‚ÇÅ).top f‚ÇÅ (h ‚ñ∏ (hat_powerises f‚ÇÅ).comm)).1,
  inv := (pullback_cone.is_limit.lift' (hat_powerises f‚ÇÅ).is_pb (hat_powerises f‚ÇÇ).top f‚ÇÇ (h.symm ‚ñ∏ (hat_powerises f‚ÇÇ).comm)).1,
  hom_inv_id' := by erw [‚Üê cancel_mono_id f‚ÇÅ, assoc, lift'_right, lift'_right],
  inv_hom_id' := by erw [‚Üê cancel_mono_id f‚ÇÇ, assoc, lift'_right, lift'_right] }

lemma very_inj {B R‚ÇÅ R‚ÇÇ : C} {f‚ÇÅ : R‚ÇÅ ‚ü∂ B ‚®Ø A} {f‚ÇÇ : R‚ÇÇ ‚ü∂ B ‚®Ø A} [mono f‚ÇÅ] [mono f‚ÇÇ] (h : hat f‚ÇÅ = hat f‚ÇÇ) :
  (how_inj_is_hat h).hom ‚â´ f‚ÇÇ = f‚ÇÅ :=
lift'_right _ _ _ _

lemma P_map_id (X : C) [has_power_object.{v} X] : P_map (ùüô X) = ùüô (P X) :=
hat_get_named_arrow _

lemma P_map_comp {X Y Z : C} [has_power_object.{v} X] [has_power_object.{v} Y] [has_power_object.{v} Z] (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  P_map (f ‚â´ g) = P_map g ‚â´ P_map f :=
by { erw [‚Üê name_other_pullback, Esubq, ‚Üê subq.pullback_comp, ‚Üê prod_map_id_comp], refl }

@[simps]
def P_functor [has_power_objects.{v} C] : C·µí·µñ ‚•§ C :=
{ obj := Œª X, P X.unop,
  map := Œª X Y f, P_map f.unop,
  map_id' := Œª X, P_map_id _,
  map_comp' := Œª X Y Z f g, P_map_comp _ _ }

end functor_setup

def self_adj [has_power_objects.{v} C] : is_right_adjoint (P_functor : C·µí·µñ ‚•§ C) :=
{ left := P_functor.right_op,
  adj := adjunction.mk_of_hom_equiv
  { hom_equiv := Œª A B,
    begin
      apply equiv.trans (op_equiv (opposite.op (P A)) B),
      apply equiv.trans name_bijection,
      apply equiv.trans _ name_bijection.symm,
      apply postcompose_sub_equiv_of_iso (limits.prod.braiding _ _),
    end,
    hom_equiv_naturality_left_symm' := Œª X' X Y f g,
    begin
      rw ‚Üê has_hom.hom.unop_inj.eq_iff,
      change name_subobject ((subq.post _).obj (name_bijection (f ‚â´ g))) =
             name_subobject ((subq.post _).obj (name_bijection g)) ‚â´ P_map f,
      rw [‚Üê name_other_pullback, get_named_subobject_natural_left],
      congr' 1,
      exact postcompose_pullback_comm _ (pullback_square_iso _ _ _ _ (braid_natural _ _)) _,
    end,
    hom_equiv_naturality_right' := Œª X Y Y' f g,
    begin
      change name_subobject ((subq.post _).obj (name_bijection (g.unop ‚â´ f.unop))) =
             name_subobject ((subq.post _).obj (name_bijection f.unop)) ‚â´ P_map g.unop,
      rw [‚Üê name_other_pullback, get_named_subobject_natural_left],
      congr' 1,
      exact postcompose_pullback_comm _ (pullback_square_iso _ _ _ _ (braid_natural _ _)) _,
    end } }

def diagonal (A : C) : A ‚ü∂ A ‚®Ø A := limits.prod.lift (ùüô A) (ùüô A)

instance mono_diagonal (A : C) : mono.{v} (diagonal A) := category_theory.mono_prod_lift_of_left _ _

def diagonal_sub (A : C) : sub (A ‚®Ø A) := sub.mk' (diagonal A)
def diagonal_subq (A : C) : subq (A ‚®Ø A) := ‚ü¶diagonal_sub A‚üß

-- @[reducible]
def singleton_arrow (A : C) [has_power_object.{v} A] : A ‚ü∂ P A := hat (diagonal A)

lemma seven_six_one {A B : C} [has_power_object.{v} B] (f : A ‚ü∂ B) :
  hat (limits.prod.lift (ùüô A) f) = f ‚â´ singleton_arrow B :=
begin
  rw [singleton_arrow, ‚Üê hat_natural_left],
  apply lifting (pullback.lift f _ _) (pullback.snd ‚â´ limits.prod.fst) (pullback.lift_snd _ _ _) _,
  { rw [prod.lift_map, diagonal],
    apply prod.hom_ext; simp },
  { apply prod.hom_ext,
    { simp only [prod.lift_fst, assoc, comp_id] },
    { rw [assoc, prod.lift_snd, assoc, ‚Üê limits.prod.map_fst f (ùüô _), ‚Üê comp_id limits.prod.snd,
          ‚Üê limits.prod.map_snd f _, ‚Üê pullback.condition_assoc, ‚Üê pullback.condition_assoc, diagonal],
      simp } }
end

lemma seven_six_two {A B : C} [has_power_object.{v} A] [has_power_object.{v} B] (f : A ‚ü∂ B) :
  hat (limits.prod.lift f (ùüô A)) = singleton_arrow B ‚â´ P_map f :=
begin
  rw [singleton_arrow, ‚Üê hat_natural_right],
  apply lifting (pullback.lift f _ _) (pullback.snd ‚â´ limits.prod.snd) (pullback.lift_snd _ _ _) _,
  { rw [prod.lift_map, diagonal],
    apply prod.hom_ext; simp },
  { apply prod.hom_ext,
    { rw [assoc, prod.lift_fst, assoc,  ‚Üê limits.prod.map_snd (ùüô _) f, ‚Üê pullback.condition_assoc,
          ‚Üê comp_id limits.prod.fst, ‚Üê limits.prod.map_fst (ùüô _) f, ‚Üê pullback.condition_assoc, diagonal],
      simp },
    { simp only [assoc, comp_id, prod.lift_snd] } },
end

instance singleton_mono (A : C) [has_power_object.{v} A] : mono (singleton_arrow A) :=
‚ü®Œª Z g h w,
begin
  rw [‚Üê seven_six_one, ‚Üê seven_six_one] at w,
  have q := very_inj w =‚â´ limits.prod.fst,
  have r := very_inj w =‚â´ limits.prod.snd,
  simp only [prod.lift_fst, assoc, comp_id] at q,
  simpa [q] using r.symm,
end‚ü©

lemma p_faithful {A B : C} [has_power_object.{v} A] [has_power_object.{v} B] {f g : A ‚ü∂ B} (k : P_map f = P_map g) :
  f = g :=
begin
  have w := singleton_arrow _ ‚â´= k,
  rw [‚Üê seven_six_two, ‚Üê seven_six_two] at w,
  have q := very_inj w =‚â´ limits.prod.fst,
  have r := very_inj w =‚â´ limits.prod.snd,
  simp only [prod.lift_snd, assoc, comp_id] at r,
  simpa [r] using q.symm,
end

instance pfaithful [has_power_objects.{v} C] : faithful (P_functor : C·µí·µñ ‚•§ C) :=
‚ü®Œª A B f g k, has_hom.hom.unop_inj (p_faithful k)‚ü©

def internal_image {A B : C} [has_power_object.{v} A] [has_power_object.{v} B] (f : A ‚ü∂ B) [mono f] : P A ‚ü∂ P B :=
hat (mem A ‚â´ limits.prod.map (ùüô (P A)) f)

-- TODO: this doesn't use pasting so it's super long. can we make it nicer by using pasting?
-- TODO: if not, it's still a horribly long proof which desperately needs a cleanup
lemma naturalish {A B : C} [has_power_object.{v} A] [has_power_object.{v} B] (f : A ‚ü∂ B) [mono f] {R D : C} (m : R ‚ü∂ D ‚®Ø A) [mono m] :
  hat m ‚â´ internal_image f = hat (m ‚â´ limits.prod.map (ùüô D) f) :=
begin
  have comm : limits.prod.map (hat m) (ùüô _) ‚â´ limits.prod.map (ùüô _) f = limits.prod.map (ùüô _) f ‚â´ limits.prod.map (hat m) (ùüô _),
    rw prod_map_map,
  change hat m ‚â´ name_bijection.symm ((subq.post (limits.prod.map _ _)).obj (mem_subq A)) = name_bijection.symm ((subq.post _).obj ‚ü¶sub.mk' m‚üß),
  rw [‚Üê name_pullback, ‚Üê postcompose_pullback_comm comm _, pullback_along_hat_eq_self], refl,
  refine is_limit.mk''' _ _ _,
    exact (category_theory.mono_prod_map (ùüô D) f),
  intro s,
  refine ‚ü®_, _‚ü©,
  apply prod.lift (s.snd ‚â´ limits.prod.fst) (s.fst ‚â´ limits.prod.snd),
  erw [prod.lift_map, comp_id, assoc, ‚Üê limits.prod.map_snd (ùüô _), s.condition_assoc,
       limits.prod.map_snd, comp_id],
  apply prod.hom_ext; simp,
end

lemma internal_image_map_comp {X Y Z : C} [has_power_object.{v} X] [has_power_object.{v} Y] [has_power_object.{v} Z]
  (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [mono f] [mono g] :
  internal_image (f ‚â´ g) = internal_image f ‚â´ internal_image g :=
begin
  erw [naturalish, internal_image],
  congr' 1,
  rw [assoc, prod_map_id_comp],
end

lemma internal_image_map_id {X : C} [has_power_object.{v} X] : internal_image (ùüô X) = ùüô (P X) :=
begin
  change name_subobject ((subq.post (limits.prod.map _ _)).obj (mem_subq _)) = _,
  rw [name_bijection.symm_apply_eq, get_named_subobject_eq_pullback_mem],
  conv { for (limits.prod.map _ _) [1, 2] { rw prod_map_id_id } },
  rw [subq.post_id, subq.pullback_id],
end

theorem beck_chevalley {A B C' D : C}
  [has_power_object.{v} A] [has_power_object.{v} B]
  [has_power_object.{v} C'] [has_power_object.{v} D]
  {h : D ‚ü∂ A} {f : A ‚ü∂ C'} {k : D ‚ü∂ B} {g : B ‚ü∂ C'} (comm : h ‚â´ f = k ‚â´ g) [mono f] [mono k]
  (t : is_limit (pullback_cone.mk h k comm)) :
  internal_image f ‚â´ P_map g = P_map h ‚â´ internal_image k :=
begin
  erw [‚Üê hat_natural_right, naturalish],
  change name_subobject ((subq.pullback _).obj ((subq.post (limits.prod.map _ _)).obj (mem_subq A))) =
         name_subobject ((subq.post (limits.prod.map _ _)).obj ((subq.pullback _).obj (mem_subq A))),
  rw equiv.apply_eq_iff_eq,
  symmetry,
  apply postcompose_pullback_comm _ _,
  rw [‚Üê prod_map_id_comp, comm, prod_map_id_comp],
  haveI : preserves_limits_of_shape walking_cospan _ := prod_preserves_connected_limits (P A),
  apply preserves_pullback_cone (prod_functor.obj (P A)) _ _ _ _ comm t,
end

variable (C)
def weak_topos_has_subobj [has_power_object.{v} (‚ä§_ C)] : has_subobject_classifier.{v} C :=
{ Œ© := P (‚ä§_ C),
  Œ©‚ÇÄ := ni (‚ä§_ C),
  truth := mem (‚ä§_ C) ‚â´ (prod.right_unitor _).hom,
  is_subobj_classifier :=
  { classifier_of := Œª U X f hf, by exactI hat (f ‚â´ (prod.right_unitor _).inv),
    classifies' := Œª U X f hf, by exactI
    begin
      change has_pullback_top _ _ _,
      conv {congr, rw [‚Üê comp_id f, ‚Üê (prod.right_unitor X).inv_hom_id, ‚Üê assoc] },
      apply stretch_hpb_down _ _ _ limits.prod.fst _ _ (hat_powerises _) (limits.prod.map_fst _ _),
      apply pullback_flip (pullback_prod _ _),
    end,
    uniquely' := Œª U X f hf œá‚ÇÅ k,
    begin
      apply unique_hat,
      apply cut_hpb_up _ _ _ (prod.right_unitor _).hom (prod.right_unitor _).hom _ _ _ (pullback_flip (pullback_prod _ _)),
      { apply_instance },
      { rw [assoc, (prod.right_unitor X).inv_hom_id, comp_id],
        exact k },
      { apply limits.prod.map_fst }
    end } }
variable {C}

instance p_reflects_iso [has_power_objects.{v} C] : reflects_isomorphisms (P_functor : C·µí·µñ ‚•§ C) :=
{ reflects := Œª A B f i, by exactI
begin
  suffices : is_iso f.unop,
    resetI,
    refine ‚ü®this.inv.op,
            has_hom.hom.unop_inj (is_iso.inv_hom_id f.unop),
            has_hom.hom.unop_inj (is_iso.hom_inv_id f.unop)‚ü©,
  haveI : has_subobject_classifier.{v} C := weak_topos_has_subobj _,
  haveI := reflects_isos _ (P_functor.right_op : C ‚•§ _),
  haveI : is_iso (P_functor.right_op.map f.unop) :=
    ‚ü®i.inv.op, has_hom.hom.unop_inj (is_iso.inv_hom_id _),
               has_hom.hom.unop_inj (is_iso.hom_inv_id _)‚ü©,
  refine is_iso_of_reflects_iso f.unop P_functor.right_op,
end }

def exists_power {A B : C} [has_power_object.{v} A] [has_power_object.{v} B] (f : A ‚ü∂ B) [mono f] :
  internal_image f ‚â´ P_map f = ùüô (P A) :=
by rw [beck_chevalley _ (pullback_of_mono f), P_map_id, internal_image_map_id, comp_id]

instance fin_category_op (J : Type v) [small_category J] [fcj : fin_category J] : fin_category J·µí·µñ :=
{ decidable_eq_obj := Œª x y, decidable_of_decidable_of_iff infer_instance opposite.unop_injective.eq_iff,
  fintype_obj :=
    { elems := finset.map ‚ü®opposite.op, opposite.op_injective‚ü© _,
      complete := Œª x, finset.mem_map_of_mem _ (fintype.complete x.unop) },
  decidable_eq_hom := Œª x y f g, decidable_of_decidable_of_iff infer_instance has_hom.hom.unop_inj.eq_iff,
  fintype_hom := Œª X Y,
  { elems := (@fin_category.fintype_hom J _ fcj Y.unop X.unop).elems.map ‚ü®has_hom.hom.op, has_hom.hom.op_inj‚ü©,
    complete := Œª f, finset.mem_map_of_mem _ (fintype.complete f.unop) } }

local attribute [instance] has_colimits_of_shape_op_of_has_limits_of_shape

instance pare [has_power_objects.{v} C] : monadic_right_adjoint (P_functor : C·µí·µñ ‚•§ C) :=
{ to_is_right_adjoint := self_adj,
  eqv :=
  begin
    apply reflexive_monadicity_theorem _ _ category_theory.p_reflects_iso,
    { intros _ _ _ _ _, apply_instance },
    { rintros B' A' f' g' ‚ü®r', rf, rg‚ü©,
      refine { preserves := Œª c t, _ },
      let e : c.X.unop ‚ü∂ A'.unop := (cofork.œÄ c).unop,
      haveI : split_mono g'.unop := ‚ü®r'.unop, by { rw [auto_param_eq, ‚Üê unop_comp, rg], refl }‚ü©,
      haveI : epi (cofork.œÄ c) := epi_of_is_colimit_parallel_pair t,
      haveI mono_e : mono e := category_theory.unop_mono_of_epi _,
      have : internal_image g'.unop ‚â´ P_map f'.unop = P_map e ‚â´ internal_image e := beck_chevalley _ _,
      apply colimit_of_splits (P_functor.map_cocone c) _ (internal_image g'.unop) (exists_power e) (exists_power g'.unop) this,
        rw [‚Üê unop_comp, ‚Üê cofork.condition c], refl,
      refine is_limit.mk''' _ mono_e (Œª s, _),
      have equal_legs : s.fst = s.snd,
        simpa [‚Üê unop_comp, rf, rg] using s.condition =‚â´ r'.unop,
      refine ‚ü®(cofork.is_colimit.desc' t s.fst.op _).1.unop, _‚ü©,
      { rw [‚Üê has_hom.hom.unop_inj.eq_iff],
        dsimp, rw [s.condition, equal_legs] },
      change (cofork.œÄ c ‚â´ (cofork.is_colimit.desc' t s.fst.op _).1).unop = _,
      rwa (cofork.is_colimit.desc' t s.fst.op _).2 }
  end }

def some_colims (J : Type v) [small_category J] [has_power_objects.{v} C] [has_limits_of_shape J·µí·µñ C] : has_colimits_of_shape J C :=
{ has_colimit := Œª F, by exactI
  begin
    suffices: has_colimit (F ‚ãô op_op_equivalence.inverse),
      resetI,
      apply adjunction.has_colimit_of_comp_equivalence F op_op_equivalence.inverse,
    let F'' : J·µí·µñ ‚•§ C·µí·µñ := (F ‚ãô op_op_equivalence.inverse).left_op,
    suffices : has_limit F'',
      resetI,
      apply limits.has_colimit_of_has_limit_left_op,
    suffices : has_limit (F'' ‚ãô P_functor),
      apply monadic_creates_limits F'' P_functor,
    apply_instance
  end }

namespace intersect

variables {A} [has_power_object.{v} A]

def intersect_names {B : C} (m n : B ‚ü∂ P A) : B ‚ü∂ P A :=
name_subobject $ name_bijection m ‚äì name_bijection n

def intersect_names_natural {B B' : C} (f : B' ‚ü∂ B) (m n : B ‚ü∂ P A) :
  f ‚â´ intersect_names m n = intersect_names (f ‚â´ m) (f ‚â´ n) :=
begin
  dunfold intersect_names,
  rw [get_named_subobject_natural_left, get_named_subobject_natural_left, ‚Üê inf_pullback,
      name_bijection.eq_symm_apply, get_named_subobject_natural_left, name_bijection.apply_symm_apply],
end

def intersect (A : C) [has_power_object.{v} A] : P A ‚®Ø P A ‚ü∂ P A := intersect_names limits.prod.fst limits.prod.snd

end intersect

@[priority 10000] instance [has_finite_limits.{v} C] {B : C} : has_finite_limits.{v} (over B) :=
begin
  haveI := has_finite_wide_pullbacks_of_has_finite_limits C,
  apply over.has_finite_limits,
end

def P‚ÇÅ_obj (A : C) [has_power_object.{v} A] : C := equalizer (intersect.intersect A) limits.prod.fst
def P‚ÇÅ_arrow (A : C) [has_power_object.{v} A] : P‚ÇÅ_obj A ‚ü∂ P A ‚®Ø P A := equalizer.Œπ (intersect.intersect A) limits.prod.fst
instance P‚ÇÅ_arrow_mono (A : C) [has_power_object.{v} A] : mono (P‚ÇÅ_arrow A) := equalizer.Œπ_mono
def P‚ÇÅ_sub (A : C) [has_power_object.{v} A] : subq (P A ‚®Ø P A) := ‚ü¶sub.mk' (P‚ÇÅ_arrow A)‚üß

lemma leq_prop' (A B : C) (m n : subq (B ‚®Ø A)) [has_power_object.{v} A] :
  m ‚â§ n ‚Üî limits.prod.lift (name_subobject m) (name_subobject n) ‚â´ intersect.intersect A = limits.prod.lift (name_subobject m) (name_subobject n) ‚â´ limits.prod.fst :=
begin
  rw [‚Üê inf_eq_left, intersect.intersect, intersect.intersect_names_natural, prod.lift_fst,
      prod.lift_snd, intersect.intersect_names, name_bijection.eq_symm_apply],
  simp only [name_bijection.apply_symm_apply],
end

lemma leq_prop (A B R‚ÇÅ R‚ÇÇ : C) [has_power_object.{v} A] (m : R‚ÇÅ ‚ü∂ B ‚®Ø A) (n : R‚ÇÇ ‚ü∂ B ‚®Ø A) [mono m] [mono n] :
  factors_through m n ‚Üî limits.prod.lift (hat m) (hat n) ‚â´ intersect.intersect A = limits.prod.lift (hat m) (hat n) ‚â´ limits.prod.fst :=
leq_prop' _ _ ‚ü¶sub.mk' m‚üß ‚ü¶sub.mk' n‚üß

-- lemma leq_iff_factor (A B R‚ÇÅ R‚ÇÇ : C) [has_power_object.{v} A] (m : R‚ÇÅ ‚ü∂ B ‚®Ø A) (n : R‚ÇÇ ‚ü∂ B ‚®Ø A) [mono m] [mono n] :
--   factors_through m n ‚Üî factors_through (prod.lift (hat m) (hat n)) (P‚ÇÅ_arrow A) :=
-- begin
--   rw [leq_prop, factors_through],

--   -- refine ‚ü®Œª k, ‚ü®_, (equalizer.lift' _ k).2‚ü©, _‚ü©,
--   -- rintro ‚ü®k, hk‚ü©,
--   -- simp [‚Üêhk, P‚ÇÅ_arrow, equalizer.condition],
-- end

namespace slicing

-- EVERYTHING FROM HERE DOWN NEEDS TIDYING!!

-- def lift_exists_of_regular {X Y : C} {r : X ‚ü∂ Y} [hr : regular_mono r] {Z : C} {l : Z ‚ü∂ Y} (h : ‚àÉ (q : Z ‚ü∂ X), q ‚â´ r = l) : {q // q ‚â´ r = l} :=
-- begin
--   apply fork.is_limit.lift' hr.is_limit l,
--   cases h,
--   simp [‚Üê h_h, hr.w],
-- end

-- def power_object_of_hats {A PA : C} (mem : sub'.{v} (PA ‚®Ø A)) (hats : Œ† {B} (f : sub'.{v} (B ‚®Ø A)), B ‚ü∂ PA)
--   [regular_mono mem.arrow.hom]
--   (mediate : Œ† {B} (f : sub'.{v} (B ‚®Ø A)), { k : pullback mem.arrow.hom (limits.prod.map (hats f) (ùüô _)) ‚âÖ f.arrow.left // k.hom ‚â´ f.arrow.hom = pullback.snd }) :
-- is_power_object.{v} mem.arrow.hom :=
-- { hat := Œª B R m hm, by exactI hats (sub'.mk' m),
--   powerises' := Œª B R m hm, by exactI
--   begin
--     change has_pullback_top _ _ _,
--     obtain ‚ü®‚ü®hom, inv, hom_inv_id, inv_hom_id‚ü©, hq‚ü© := mediate (sub'.mk' m),
--     dsimp at hom inv hom_inv_id inv_hom_id hq,
--     -- let q' : R ‚ü∂ pullback mem.arrow.hom (limits.prod.map (hats (sub'.mk' m)) (ùüô A)) := pullback.lift _ m _,
--     -- sorry,
--     -- refine ‚ü®_, _, _‚ü©,
--   end

-- }

variables {B} (f g : over B)

-- def reflect_pullback (P Q R S : over B) (f : P ‚ü∂ Q) (g : Q ‚ü∂ S) (h : P ‚ü∂ R) (k : R ‚ü∂ S)
--   (comm : f ‚â´ g = h ‚â´ k) (t : is_limit (pullback_cone.mk f.left h.left (begin exact congr_arg comma_morphism.left comm end))) :
-- is_limit (pullback_cone.mk f h comm) :=
-- begin
--   apply is_limit.mk',
--   intro s,
--   let s' : pullback_cone g.left k.left := pullback_cone.mk (pullback_cone.fst s).left (pullback_cone.snd s).left (congr_arg comma_morphism.left (pullback_cone.condition s)),
--   refine ‚ü®over.hom_mk (t.lift s') _, _, _, _‚ü©,
--   dsimp, change t.lift s' ‚â´ P.hom = _, rw ‚Üê over.w f, slice_lhs 1 2 {erw t.fac _ walking_cospan.left}, exact over.w (pullback_cone.fst s),
--   ext1, dsimp, exact t.fac _ walking_cospan.left,
--   ext1, dsimp, exact t.fac _ walking_cospan.right,
--   intros m m‚ÇÅ m‚ÇÇ,
--   ext1,
--   dsimp,
--   refine t.hom_ext _,
--   apply pullback_cone.equalizer_ext (pullback_cone.mk f.left h.left _),
--   erw t.fac _ walking_cospan.left,
--   exact congr_arg comma_morphism.left m‚ÇÅ,
--   erw t.fac _ walking_cospan.right,
--   exact congr_arg comma_morphism.left m‚ÇÇ,
-- end

-- def preserve_pullback {P Q R S : over B} {f : P ‚ü∂ Q} {g : Q ‚ü∂ S} {h : P ‚ü∂ R} {k : R ‚ü∂ S}
--   {comm : f ‚â´ g = h ‚â´ k} (t : is_limit (pullback_cone.mk f h comm)) :
-- is_limit (pullback_cone.mk f.left h.left (begin exact congr_arg comma_morphism.left comm end)) :=
-- begin
--   apply is_limit.mk',
--   intro s,
--   let sX' : over B := over.mk (pullback_cone.snd s ‚â´ R.hom),
--   have: pullback_cone.fst s ‚â´ Q.hom = pullback_cone.snd s ‚â´ R.hom,
--     rw [‚Üê over.w g, pullback_cone.condition_assoc s, over.w k],
--   let fst' : sX' ‚ü∂ Q := over.hom_mk (pullback_cone.fst s) (by assumption),
--   let snd' : sX' ‚ü∂ R := over.hom_mk (pullback_cone.snd s),
--   have comm': fst' ‚â´ g = snd' ‚â´ k,
--     ext, dsimp, apply pullback_cone.condition s,
--   let q : sX' ‚ü∂ P := t.lift (pullback_cone.mk fst' snd' comm'),
--   have qf : q ‚â´ f = fst' := t.fac _ walking_cospan.left,
--   have qh : q ‚â´ h = snd' := t.fac _ walking_cospan.right,
--   refine ‚ü®q.left, congr_arg comma_morphism.left qf, congr_arg comma_morphism.left qh, _‚ü©,
--   intros m m‚ÇÅ m‚ÇÇ,
--   have z: m ‚â´ P.hom = pullback_cone.snd s ‚â´ R.hom,
--   { rw [‚Üê over.w h, ‚Üê m‚ÇÇ, assoc], refl },
--   let m' : sX' ‚ü∂ P := over.hom_mk m (by apply z),
--   have: m' = q,
--     apply t.hom_ext,
--     refine pullback_cone.equalizer_ext (pullback_cone.mk f h comm) _ _,
--     { erw qf,
--       ext,
--       dsimp,
--       erw m‚ÇÅ },
--     { erw qh,
--       ext,
--       dsimp,
--       erw m‚ÇÇ },
--   apply congr_arg comma_morphism.left this,
-- end

variables [has_power_object.{v} B] [has_power_object.{v} f.left]

-- @[reducible]
def bottom : P f.left ‚®Ø B ‚ü∂ P f.left ‚®Ø P f.left := limits.prod.map (ùüô _) (singleton_arrow B ‚â´ P_map f.hom)

def Q : C := pullback (P‚ÇÅ_arrow f.left) (bottom f)
def hk : Q f ‚ü∂ P f.left ‚®Ø B := pullback.snd
def k : Q f ‚ü∂ B        := hk f ‚â´ limits.prod.snd
def h : Q f ‚ü∂ P f.left := hk f ‚â´ limits.prod.fst
def over_pow : over B  := over.mk (k f)

def up : C := pullback (mem f.left) (limits.prod.map (h f) (ùüô f.left))
def h' : up f ‚ü∂ Q f ‚®Ø f.left := pullback.snd
instance mono_h' : mono (h' f) := pullback.snd_of_mono
instance mono_hk : mono (hk f) := pullback.snd_of_mono

def hat_h' : hat (h' f) = h f :=
unique_hat has_pullback_top_of_pb

def over.ni (f : over B) [has_power_object.{v} B] [has_power_object.{v} f.left] : over B :=
over.mk (h' f ‚â´ limits.prod.snd ‚â´ f.hom)

-- fix me.
def prop (f : over B) [has_power_object.{v} B] [has_power_object.{v} f.left] :
  ‚àÉ q, q ‚â´ (pullback.snd : pullback (prod.lift f.hom (ùüô f.left)) (limits.prod.map ((k f) : _ ‚ü∂ B) (ùüô f.left)) ‚ü∂ _) = h' f :=
begin
  have: pullback.fst ‚â´ P‚ÇÅ_arrow f.left = limits.prod.lift (h f) (k f ‚â´ singleton_arrow B ‚â´ P_map f.hom),
    rw [pullback.condition],
    dunfold bottom,
    apply prod.hom_ext,
    { rw [assoc, prod.lift_fst, h, hk, limits.prod.map_fst, comp_id] },
    { rw [assoc, prod.lift_snd, k, hk, limits.prod.map_snd, assoc] },
  rw [‚Üê seven_six_two, ‚Üê hat_natural_left, ‚Üê hat_h' f] at this,
  have: limits.prod.lift (hat (h' f)) (hat pullback.snd) ‚â´ intersect.intersect f.left = limits.prod.lift (hat (h' f)) (hat pullback.snd) ‚â´ limits.prod.fst,
    rw ‚Üê this,
    erw [assoc, assoc, equalizer.condition], refl,
  rw ‚Üê leq_prop at this,
  cases this with a,
  refine ‚ü®_, over.w a‚ü©,
end

-- @[reducible]
def over.mem : over.ni f ‚ü∂ over_pow f ‚®Ø f :=
begin
  apply prod.lift _ _,
  apply over.hom_mk _ _,
  exact h' f ‚â´ limits.prod.fst,
  dsimp [over_pow, over.ni, hk],
  change (((h' f : up f ‚ü∂ _) ‚â´ (limits.prod.fst : Q f ‚®Ø f.left ‚ü∂ Q f)) : _ ‚ü∂ Q f) ‚â´ (k f : Q f ‚ü∂ B) =
    (h' f : up f ‚ü∂ Q f ‚®Ø f.left) ‚â´ (limits.prod.snd : Q f ‚®Ø f.left ‚ü∂ f.left) ‚â´ (f.hom : f.left ‚ü∂ B),
  obtain ‚ü®q, hq‚ü© := prop f,
  have z : (pullback.fst : pullback (prod.lift f.hom (ùüô f.left)) (limits.prod.map ((k f) : _ ‚ü∂ B) (ùüô f.left)) ‚ü∂ _) ‚â´ _ = _ ‚â´ _ := pullback.condition,
    have z‚ÇÅ := z =‚â´ limits.prod.fst,
    rw [assoc, prod.lift_fst, assoc, limits.prod.map_fst] at z‚ÇÅ,
    have z‚ÇÇ := z =‚â´ limits.prod.snd,
    erw [assoc, assoc, prod.lift_snd, limits.prod.map_snd, comp_id, comp_id] at z‚ÇÇ,
    rw [‚Üê hq, assoc, assoc, ‚Üê z‚ÇÅ, z‚ÇÇ, assoc, assoc],
  apply over.hom_mk _ _,
  exact h' f ‚â´ limits.prod.snd,
  simp only [assoc, auto_param_eq], refl,
end
-- pretty gross.
instance over.mem_mono : mono (over.mem f) :=
begin
  refine ‚ü®Œª Z p q eq, _‚ü©,
  ext1,
  rw ‚Üê cancel_mono (h' f),
  apply prod.hom_ext,
  rw [assoc, assoc],
  have e‚ÇÅ := eq =‚â´ limits.prod.fst,
  rw [over.mem, assoc, assoc, prod.lift_fst] at e‚ÇÅ,
  exact congr_arg comma_morphism.left e‚ÇÅ,
  have e‚ÇÇ := eq =‚â´ limits.prod.snd,
  rw [over.mem, assoc, assoc, prod.lift_snd] at e‚ÇÇ,
  rw [assoc, assoc],
  exact congr_arg comma_morphism.left e‚ÇÇ,
end

section hat

variables {f g}
variables {r : over B} (m : r ‚ü∂ g ‚®Ø f) [mono m]

def m' : r.left ‚ü∂ (g ‚®Ø f).left := m.left
instance m'_mono : mono (m' m) := category_theory.over_mono m

def m'' : r.left ‚ü∂ g.left ‚®Ø f.left := m' m ‚â´ magic_arrow f g
instance m''_mono : mono (m'' m) := mono_comp _ _

-- @[reducible]
def mhat : g.left ‚ü∂ P f.left := hat (m'' m)
-- @[reducible]
def l : g.left ‚ü∂ P f.left ‚®Ø P f.left := prod.lift (mhat m) g.hom ‚â´ bottom f
lemma l_eq : l m = prod.lift (hat (m'' m)) (g.hom ‚â´ (singleton_arrow B : B ‚ü∂ P B) ‚â´ P_map f.hom) :=
begin
  rw [l, bottom, prod.lift_map, comp_id], refl,
end

lemma llem : l m ‚â´ intersect.intersect f.left = l m ‚â´ limits.prod.fst :=
begin
  have := l_eq m,
  erw [‚Üê seven_six_two, ‚Üê hat_natural_left] at this,
  rw [this, ‚Üê leq_prop],
  refine ‚ü®_‚ü©,
  apply over.hom_mk _ _,
  { apply pullback.lift (m'' m ‚â´ limits.prod.snd) (m'' m) _,
    apply prod.hom_ext,
    { erw [assoc, assoc, assoc, assoc, m'', assoc, prod.lift_fst, limits.prod.map_fst],
      slice_lhs 2 3 {rw prod.lift_snd},
      slice_rhs 2 3 {rw prod.lift_fst},
      rw over.w (limits.prod.fst : g ‚®Ø f ‚ü∂ g),
      rw over.w (limits.prod.snd : g ‚®Ø f ‚ü∂ f) },
    { erw [assoc, assoc, assoc, assoc, assoc, prod.lift_snd, comp_id, limits.prod.map_snd, comp_id] } },
  { dsimp, rw limit.lift_œÄ, refl }
end
-- @[reducible]
def top : g.left ‚ü∂ P‚ÇÅ_obj f.left := equalizer.lift (l m) (llem m)
-- @[reducible]
def h'' : g.left ‚ü∂ Q f := pullback.lift (top m) (prod.lift (mhat m) g.hom) (limit.lift_œÄ _ _)
-- @[reducible]
def make_arrow : g ‚ü∂ over_pow f := over.hom_mk (h'' m) $ by { dsimp [over_pow, hk, k, h''], simp }
-- @[reducible]
def square_top (m : r ‚ü∂ g ‚®Ø f) [mono m] : r ‚ü∂ over.ni f :=
begin
  refine over.hom_mk (pullback.lift (hat_powerises (m'' m)).top _ _) _,
  { apply (m'' m) ‚â´ limits.prod.map (h'' m) (ùüô _) },
  { rw (hat_powerises (m'' m)).comm, conv_rhs {rw [assoc, ‚Üê prod_map_comp_id]}, congr' 2,
    erw [h, hk, h'', limit.lift_œÄ_assoc, prod.lift_fst, mhat] },
  { dsimp [h'], erw [limit.lift_œÄ_assoc, assoc, limits.prod.map_snd_assoc, id_comp],
    erw [‚Üê over.w m, assoc, prod.lift_snd_assoc, over.w (limits.prod.snd : g ‚®Ø f ‚ü∂ f)], refl }
end
def alt_square_commutes : square_top m ‚â´ over.mem f ‚â´ limits.prod.fst = (m ‚â´ limits.prod.fst) ‚â´ make_arrow m :=
begin
  rw [assoc, over.mem, prod.lift_fst, make_arrow],
  ext1,
  dsimp [h', m'', magic_arrow, h'', square_top],
  rw limit.lift_œÄ_assoc,
  dsimp,
  rw [assoc, limits.prod.map_fst, assoc, prod.lift_fst_assoc], refl
end
def square_commutes : square_top m ‚â´ over.mem f = m ‚â´ limits.prod.map (make_arrow m) (ùüô _) :=
begin
  apply prod.hom_ext,
  { rw [assoc, alt_square_commutes, assoc, assoc, limits.prod.map_fst] },
  { rw [assoc, over.mem, prod.lift_snd, assoc, limits.prod.map_snd, comp_id],
    ext1,
    dsimp [h', square_top],
    rw limit.lift_œÄ_assoc,
    dsimp,
    rw [assoc, limits.prod.map_snd, comp_id],
    simp [m'', m'] }
end

def alt_square_pb : is_limit (pullback_cone.mk _ _ (alt_square_commutes m)) :=
begin
  apply reflects_pullback_cone over.forget,
  -- apply reflect_pullback,
  dsimp [square_top],
  refine is_limit.mk' _ _,
  intro s,
  have lem : (pullback_cone.fst s ‚â´ pullback.fst) ‚â´ mem f.left =
    prod.lift (pullback_cone.snd s) (pullback_cone.fst s ‚â´ pullback.fst ‚â´ mem f.left ‚â´ limits.prod.snd) ‚â´
      limits.prod.map (hat (m'' m)) (ùüô f.left),
  { apply prod.hom_ext,
    { rw [assoc, assoc, assoc, limits.prod.map_fst, prod.lift_fst_assoc,
          category_theory.limits.pullback.condition_assoc, limits.prod.map_fst],
      have : pullback_cone.fst s ‚â´ (over.mem f ‚â´ _).left = _ := pullback_cone.condition s,
      dsimp only [over.mem] at this,
      rw [prod.lift_fst] at this,
      dsimp [h'] at this,
      slice_lhs 1 3 {rw this},
      dsimp [h, hk, make_arrow, h''],
      rw [assoc],
      rw [pullback.lift_snd_assoc, prod.lift_fst], refl },
    { rw [assoc, assoc, assoc, limits.prod.map_snd, comp_id, prod.lift_snd] } },
  let t : s.X ‚ü∂ r.left := (hat_powerises (m'' m)).is_pb.lift (pullback_cone.mk _ _ lem),
  have t‚ÇÉ : t ‚â´ m'' m ‚â´ limits.prod.fst = pullback_cone.snd s,
    rw ‚Üê assoc,
    erw (hat_powerises (m'' m)).is_pb.fac (pullback_cone.mk _ _ lem) walking_cospan.right,
    dsimp,
    rw prod.lift_fst,
  have t‚ÇÇ : t ‚â´ m'' m ‚â´ limits.prod.snd = pullback_cone.fst s ‚â´ pullback.fst ‚â´ mem f.left ‚â´ limits.prod.snd,
    rw ‚Üê assoc,
    erw (hat_powerises (m'' m)).is_pb.fac (pullback_cone.mk _ _ lem) walking_cospan.right,
    dsimp,
    rw prod.lift_snd,
  have t‚ÇÅ: t ‚â´ (hat_powerises (m'' m)).top = pullback_cone.fst s ‚â´ pullback.fst,
    erw (hat_powerises (m'' m)).is_pb.fac (pullback_cone.mk _ _ lem) walking_cospan.left,
    refl,
  refine ‚ü®t, _, _, _‚ü©,
  { change t ‚â´ pullback.lift (hat_powerises (m'' m)).top (m'' m ‚â´ limits.prod.map (h'' m) (ùüô f.left)) _ = s.œÄ.app walking_cospan.left,
    apply pullback.hom_ext,
    { rw ‚Üê t‚ÇÅ, simp },
    { rw [assoc], slice_lhs 2 3 {rw limit.lift_œÄ},
      dsimp,
      apply prod.hom_ext,
      { rw [assoc, assoc, limits.prod.map_fst],
        slice_lhs 1 3 {rw t‚ÇÉ},
        rw [h''],
        erw ‚Üê pullback_cone.condition s,
        rw assoc,
        change pullback_cone.fst s ‚â´ (over.mem f ‚â´ limits.prod.fst).left = s.œÄ.app walking_cospan.left ‚â´ pullback.snd ‚â´ limits.prod.fst,
        erw prod.lift_fst,
        refl },
      { rw [assoc, assoc, limits.prod.map_snd, comp_id, t‚ÇÇ,
            category_theory.limits.pullback.condition_assoc, limits.prod.map_snd,
            comp_id, assoc] } } },
  { dunfold pullback_cone.snd,
    dsimp,
    rw [m'', assoc, magic_arrow, prod.lift_fst] at t‚ÇÉ,
    exact t‚ÇÉ },
  { intros t' m‚ÇÅ m‚ÇÇ,
    have m‚ÇÅ' : t' ‚â´ pullback.lift (hat_powerises (m'' m)).top (m'' m ‚â´ limits.prod.map (h'' m) (ùüô f.left)) _ =
    pullback_cone.fst s := m‚ÇÅ,
    have m‚ÇÇ' : t' ‚â´ m.left ‚â´ _ = pullback_cone.snd s := m‚ÇÇ,
    clear m‚ÇÅ m‚ÇÇ,
    rw ‚Üê cancel_mono (m'' m),
    change t' ‚â´ m' m ‚â´ magic_arrow f g = t ‚â´ m' m ‚â´ magic_arrow f g,
    apply prod.hom_ext,
    { rw [assoc, assoc],
      slice_lhs 3 4 {rw prod.lift_fst},
      rw m',
      rw m‚ÇÇ',
      rw ‚Üê t‚ÇÉ,
      rw assoc, refl },
    { conv_rhs {erw [assoc, t‚ÇÇ, ‚Üê m‚ÇÅ']},
      rw [assoc, assoc, assoc],
      slice_rhs 2 3 {rw limit.lift_œÄ},
      dsimp,
      rw (hat_powerises (m'' m)).comm,
      rw [assoc, limits.prod.map_snd, comp_id],
      simp [m''] } },
  refine ‚ü®Œª K, by apply_instance‚ü©,
end

end hat

def main' (f : over B) [has_power_object.{v} f.left] : is_power_object (over.mem f) :=
{ hat := Œª b r m hm, by exactI make_arrow m,
  powerises' := Œª g r m hm, by exactI
  begin
    refine ‚ü®square_top m, square_commutes m, _‚ü©,
    apply is_limit.mk' _ _,
    intro s,
    have comm : pullback_cone.fst s ‚â´ over.mem f ‚â´ limits.prod.fst = (pullback_cone.snd s ‚â´ limits.prod.fst) ‚â´ make_arrow m,
      rw [pullback_cone.condition_assoc s, limits.prod.map_fst, assoc],
    let s' := pullback_cone.mk _ _ comm,
    let t := (alt_square_pb m).lift s',
    have t‚ÇÅ : t ‚â´ square_top m = pullback_cone.fst s' := (alt_square_pb m).fac s' walking_cospan.left,
    have t‚ÇÇ : t ‚â´ m ‚â´ limits.prod.fst = pullback_cone.snd s' := (alt_square_pb m).fac s' walking_cospan.right,
    have t‚ÇÉ := t‚ÇÅ =‚â´ over.mem f,
      rw [assoc, square_commutes m] at t‚ÇÉ,
    replace t‚ÇÉ := t‚ÇÉ =‚â´ limits.prod.snd,
    rw [assoc, assoc, assoc, limits.prod.map_snd, comp_id] at t‚ÇÉ,
    refine ‚ü®(alt_square_pb m).lift s', (alt_square_pb m).fac s' walking_cospan.left, _, _‚ü©,
    { change t ‚â´ m = pullback_cone.snd s,
      apply prod.hom_ext,
      { rw [assoc, t‚ÇÇ], refl },
      { rw [assoc, t‚ÇÉ], erw [pullback_cone.condition_assoc s, limits.prod.map_snd, comp_id] } },
    { intros t' m‚ÇÅ m‚ÇÇ,
      apply (alt_square_pb m).hom_ext,
      apply pullback_cone.equalizer_ext (pullback_cone.mk (square_top m) (m ‚â´ limits.prod.fst) _),
      erw t‚ÇÅ,
      exact m‚ÇÅ,
      erw [t‚ÇÇ, ‚Üê assoc, m‚ÇÇ], refl }
  end,
  uniquely' := Œª g r m hm hat' p, by exactI
  begin
    ext1,
    rw ‚Üê cancel_mono (hk f),
    have z‚ÇÅ: hat'.left ‚â´ k f = g.hom := over.w hat',
    suffices z‚ÇÇ: hat'.left ‚â´ h f = (make_arrow m).left ‚â´ h f,
      apply prod.hom_ext,
      { erw [assoc, assoc, z‚ÇÇ], refl },
      { rw [assoc, assoc],
        change _ ‚â´ k f = _ ‚â´ k f,
        rw [z‚ÇÅ, make_arrow, over.hom_mk_left, h'', k, hk, pullback.lift_snd_assoc, prod.lift_snd] },
    erw [make_arrow, limit.lift_œÄ_assoc, prod.lift_fst],
    symmetry,
    apply unique_hat,
    change has_pullback_top _ _ _,
    rw prod_map_comp_id,
    apply left_right_hpb_to_both_hpb (h' f) _ has_pullback_top_of_pb,
    have: h' f = (over.mem f).left ‚â´ magic_arrow f (over_pow f),
    { apply prod.hom_ext,
      { rw [assoc, prod.lift_fst, ‚Üê over.comp_left, over.mem, prod.lift_fst], refl },
      { rw [assoc, prod.lift_snd, ‚Üê over.comp_left, over.mem, prod.lift_snd], refl } },
    rw this,
    apply stretch_hpb_down _ _ (limits.prod.map hat' (ùüô f)).left _ _ _ _ _ (magic_pb _ _ f hat'),
    apply over_forget_preserves_hpb _ _ _ p,
  end }

def main (f : over B) [has_power_object.{v} f.left] : has_power_object.{v} f :=
{ PA := over_pow f,
  niA := over.ni f,
  memA := over.mem f,
  is_power := main' f }

end slicing

instance fundamental_theorem (B : C) [has_power_objects.{v} C] : has_power_objects.{v} (over B) :=
{ has_power_object := Œª f, slicing.main f }

def comparison [has_power_objects.{v} C]
  {D : Type u‚ÇÇ} [category.{v} D] [has_finite_limits.{v} D] [has_power_objects.{v} D]
  (F : C ‚•§ D) (h : Œ† (J : Type v) [ùí•‚ÇÅ : small_category J] [@fin_category J ùí•‚ÇÅ], @preserves_limits_of_shape _ _ _ _ J ùí•‚ÇÅ F)
  (A : C) : F.obj (P A) ‚ü∂ P (F.obj A) :=
begin
  let m := F.map (mem A) ‚â´ (prod_comparison F (P A) A),
  letI : mono (F.map (mem A)) := preserves_mono_of_preserves_pullback F _ _ _,
  exact hat m,
end

def comp_natural' [has_power_objects.{v} C]
  {D : Type u‚ÇÇ} [category.{v} D] [has_finite_limits.{v} D] [has_power_objects.{v} D]
  (F : C ‚•§ D) (h : Œ† (J : Type v) [ùí•‚ÇÅ : small_category J] [@fin_category J ùí•‚ÇÅ], @preserves_limits_of_shape _ _ _ _ J ùí•‚ÇÅ F)
  (A B : C) (f : B ‚ü∂ A) :
  F.map (P_map f) ‚â´ comparison F h B = comparison F h A ‚â´ P_map (F.map f) :=
begin
  dsimp [comparison],
  rw [‚Üê hat_natural_left, ‚Üê hat_natural_right],
  let m‚ÇÅ := F.map (mem A) ‚â´ (prod_comparison F (P A) A),
  let m‚ÇÇ := F.map (mem B) ‚â´ (prod_comparison F (P B) B),
  letI : mono (F.map (mem A)) := preserves_mono_of_preserves_pullback F _ _ _,
  letI : mono (F.map (mem B)) := preserves_mono_of_preserves_pullback F _ _ _,
  letI : mono (F.map (Emap f)) := preserves_mono_of_preserves_pullback F _ _ _,
  let P‚ÇÅ := pullback (F.map (mem B) ‚â´ (prod_comparison F (P B) B)) (limits.prod.map (F.map (P_map f)) (ùüô (F.obj B))),
  let P‚ÇÇ := pullback (F.map (mem A) ‚â´ (prod_comparison F (P A) A)) (limits.prod.map (ùüô _) (F.map f)),
  let h‚ÇÅ : P‚ÇÅ ‚ü∂ _ := pullback.snd,
  let h‚ÇÇ : P‚ÇÇ ‚ü∂ _ := pullback.snd,
  change hat h‚ÇÅ = hat h‚ÇÇ,
  let s‚ÇÅ := (hat_powerises (Emap f)).is_pb,
  let s‚ÇÇ := Epb f,
  let Fs‚ÇÅ := preserves_pullback_cone F _ _ _ _ _ s‚ÇÅ,
  let Fs‚ÇÇ := preserves_pullback_cone F _ _ _ _ _ s‚ÇÇ,
  have s‚ÇÉcomm : F.map (limits.prod.map (P_map f) (ùüô B)) ‚â´ (prod_comparison F (P B) B) = (prod_comparison F (P A) B) ‚â´ limits.prod.map (F.map (P_map f)) (ùüô (F.obj B)),
    rw [prod_comparison, prod_comparison],
    apply prod.hom_ext,
    { erw [assoc, prod.lift_fst, assoc, limits.prod.map_fst, ‚Üê F.map_comp, limits.prod.map_fst, prod.lift_fst_assoc, F.map_comp] },
    { erw [assoc, prod.lift_snd, assoc, limits.prod.map_snd, comp_id, ‚Üê F.map_comp, limits.prod.map_snd, comp_id, prod.lift_snd] },
  let s‚ÇÉ := pullback_square_iso (F.map (limits.prod.map (P_map f) (ùüô _))) (prod_comparison F (P A) B) (prod_comparison F (P B) B) (limits.prod.map (F.map (P_map f)) (ùüô _)) s‚ÇÉcomm,
  let Fs‚ÇÅs‚ÇÉ := vpaste _ _ _ _ _ _ _ _ _ s‚ÇÉ Fs‚ÇÅ,
  have eq‚ÇÅ: hat h‚ÇÅ = hat (F.map (Emap f) ‚â´ (prod_comparison F (P A) B)),
  { apply lifting _ _ _ _,
    { apply Fs‚ÇÅs‚ÇÉ.lift (limit.cone _) },
    { apply limit.lift _ (pullback_cone.mk (F.map (hat_powerises (Emap f)).top) (F.map (Emap f) ‚â´ (prod_comparison F (P A) B)) _),
      rw [assoc, ‚Üê s‚ÇÉcomm, ‚Üê assoc, ‚Üê F.map_comp, (hat_powerises (Emap f)).comm, F.map_comp, assoc], refl },
    { exact (Fs‚ÇÅs‚ÇÉ.fac (limit.cone _) walking_cospan.right) },
    { rw limit.lift_œÄ, refl } },
  have s‚ÇÑcomm : F.map (limits.prod.map (ùüô (P A)) f) ‚â´ (prod_comparison F (P A) A) = (prod_comparison F (P A) B) ‚â´ limits.prod.map (ùüô (F.obj (P A))) (F.map f),
    rw [prod_comparison, prod_comparison],
    apply prod.hom_ext,
    { rw [assoc, prod.lift_fst, assoc, limits.prod.map_fst, ‚Üê F.map_comp, limits.prod.map_fst, comp_id, comp_id, prod.lift_fst] },
    { rw [assoc, prod.lift_snd, assoc, limits.prod.map_snd, ‚Üê F.map_comp, limits.prod.map_snd, prod.lift_snd_assoc, F.map_comp] },
  let s‚ÇÑ := pullback_square_iso (F.map (limits.prod.map (ùüô _) f)) (prod_comparison F (P A) B) (prod_comparison F (P A) A) (limits.prod.map (ùüô _) (F.map f)) s‚ÇÑcomm,
  let Fs‚ÇÇs‚ÇÑ := vpaste _ _ _ _ _ _ _ _ _ s‚ÇÑ Fs‚ÇÇ,
  have eq‚ÇÇ: hat h‚ÇÇ = hat (F.map (Emap f) ‚â´ (prod_comparison F (P A) B)),
  { apply lifting _ _ _ _,
    { apply Fs‚ÇÇs‚ÇÑ.lift (limit.cone _) },
    { apply limit.lift _ (pullback_cone.mk (F.map pullback.fst) (F.map (Emap f) ‚â´ (prod_comparison F (P A) B)) _),
      rw [assoc, ‚Üê s‚ÇÑcomm, ‚Üê assoc, ‚Üê F.map_comp, pullback.condition, F.map_comp, assoc], refl },
    { exact (Fs‚ÇÇs‚ÇÑ.fac (limit.cone _) walking_cospan.right) },
    { rw limit.lift_œÄ, refl } },
  rw [eq‚ÇÅ, eq‚ÇÇ],
end

-- Define F as a logical functor if this is an iso.
def comp_natural [has_power_objects.{v} C]
  {D : Type u‚ÇÇ} [category.{v} D] [has_finite_limits.{v} D] [has_power_objects.{v} D]
  (F : C ‚•§ D) [h : Œ† (J : Type v) [ùí•‚ÇÅ : small_category J] [@fin_category J ùí•‚ÇÅ], @preserves_limits_of_shape _ _ _ _ J ùí•‚ÇÅ F] :
  (P_functor ‚ãô F) ‚ü∂ (F.op ‚ãô P_functor) :=
{ app := Œª A, comparison F h A.unop,
  naturality' := Œª A B g, comp_natural' F h A.unop B.unop g.unop }

def star_power (A B : C) [has_power_object.{v} A] : (star B).obj (ni A) ‚ü∂ (star B).obj (P A) ‚®Ø (star B).obj A :=
begin
  haveI := adjunction.right_adjoint_preserves_limits (forget_adj_star B),
  exact (star B).map (mem A) ‚â´ (prod_comparison (star B) (P A) A)
end
instance star_mono (A B : C) [has_power_object.{v} A] : mono (star_power A B) :=
begin
  haveI : mono ((star B).map (mem A)) := right_adjoint_preserves_mono (forget_adj_star B) (by apply_instance),
  haveI := adjunction.right_adjoint_preserves_limits (forget_adj_star B),
  rw star_power,
  haveI : is_iso (prod_comparison (star B) (P A) A) := by apply_instance,
  apply_instance
end

def alt_prod (A : C) {B : C} (g : over B) : over B := over.mk ((limits.prod.fst : g.left ‚®Ø A ‚ü∂ g.left) ‚â´ g.hom)

@[simps]
def the_iso (A : C) {B : C} (g : over B) : g ‚®Ø (star B).obj A ‚âÖ alt_prod A g :=
{ hom :=
  begin
    apply over.hom_mk _ _,
    apply prod.lift (limits.prod.fst : g ‚®Ø _ ‚ü∂ _).left _,
    refine (limits.prod.snd : g ‚®Ø _ ‚ü∂ _).left ‚â´ limits.prod.snd,
    erw limit.lift_œÄ_assoc,
    exact over.w (limits.prod.fst : g ‚®Ø (star B).obj A ‚ü∂ _),
  end,
  inv :=
  begin
    apply prod.lift,
    refine over.hom_mk limits.prod.fst rfl,
    refine over.hom_mk (limits.prod.map g.hom (ùüô _)) (limits.prod.map_fst _ _),
  end,
  hom_inv_id' :=
  begin
    ext1,
    dsimp,
    rw ‚Üê cancel_mono (magic_arrow ((star B).obj A) g),
    rw id_comp,
    apply prod.hom_ext,
    rw [prod.lift_fst, assoc, prod.lift_fst, assoc, ‚Üê over.comp_left, prod.lift_fst, over.hom_mk_left, prod.lift_fst],
    rw [prod.lift_snd, assoc, prod.lift_snd, assoc, ‚Üê over.comp_left, prod.lift_snd, over.hom_mk_left],
    apply prod.hom_ext,
    rw [assoc, limits.prod.map_fst, prod.lift_fst_assoc, over.w (limits.prod.fst : g ‚®Ø (star B).obj A ‚ü∂ _)],
    exact (over.w (limits.prod.snd : g ‚®Ø (star B).obj A ‚ü∂ _)).symm,
    rw [assoc, limits.prod.map_snd, prod.lift_snd_assoc, comp_id],
  end,
  inv_hom_id' :=
  begin
    ext,
    dsimp,
    rw [assoc, prod.lift_fst, ‚Üê over.comp_left, prod.lift_fst, id_comp], refl,
    rw [over.comp_left, assoc, over.hom_mk_left, prod.lift_snd, ‚Üê assoc, ‚Üê over.comp_left,
        prod.lift_snd, over.hom_mk_left, limits.prod.map_snd, over.id_left, id_comp, comp_id],
  end }


def star_hat {A B : C} [has_power_object.{v} A] {g r : over B} (m : r ‚ü∂ g ‚®Ø (star B).obj A) (k : g.left ‚ü∂ P A) [mono m] : g ‚ü∂ (star B).obj (P A):=
over.hom_mk (prod.lift g.hom k) (limit.lift_œÄ _ _)

def seven_eleven_r_comm (A B : C) [has_power_object.{v} A] :
  ùüô (B ‚®Ø _) ‚â´ limits.prod.map (ùüô _) (mem A) = (star_power A B ‚â´ (the_iso A ((star B).obj (P A))).hom).left ‚â´ (prod.associator B (P A) A).hom :=
begin
  dsimp [star_power, the_iso, prod_comparison],
  rw [assoc, assoc, id_comp],
  apply prod.hom_ext,
  rw [assoc, assoc, assoc, prod.lift_fst, prod.lift_fst_assoc, limits.prod.map_fst, comp_id],
  slice_rhs 2 3 {rw ‚Üê over.comp_left},
  rw [prod.lift_fst, over.hom_mk_left, ‚Üê assoc, ‚Üê prod_map_id_comp, limits.prod.map_fst, comp_id],
  rw [assoc, assoc, assoc, prod.lift_snd, limits.prod.map_snd],
  apply prod.hom_ext,
  rw [assoc, assoc, assoc, assoc, prod.lift_fst, prod.lift_fst_assoc],
  slice_rhs 2 3 {rw ‚Üê over.comp_left},
  rw [prod.lift_fst, over.hom_mk_left, ‚Üê prod_map_id_comp_assoc, limits.prod.map_snd],
  rw [assoc, assoc, assoc, assoc, prod.lift_snd, prod.lift_snd],
  slice_rhs 2 3 {rw ‚Üê over.comp_left},
  rw [prod.lift_snd, over.hom_mk_left, ‚Üê prod_map_id_comp_assoc, limits.prod.map_snd],
end

def seven_eleven_aux (A B : C) [has_power_object.{v} A] (g r : over B) (m : r ‚ü∂ g ‚®Ø (star B).obj A) [mono m] (k : g.left ‚ü∂ P A) :
  powerises (mem A) (m ‚â´ (the_iso A g).hom).left k ‚âÖ powerises (star_power A B) m (star_hat m k) :=
begin
  have bottom_comm :
    limits.prod.map (star_hat m k) (ùüô _) ‚â´ (the_iso A _).hom =
    (the_iso A g).hom ‚â´ over.hom_mk (limits.prod.map (prod.lift g.hom k) (ùüô A))
      (by { dsimp, erw [limits.prod.map_fst_assoc, limits.prod.lift_fst], refl }),
  { dsimp [the_iso], ext : 2,
    { rw [over.comp_left, over.comp_left, over.hom_mk_left, assoc, prod.lift_fst,
          ‚Üê over.comp_left, limits.prod.map_fst, over.comp_left, star_hat, over.hom_mk_left,
          over.hom_mk_left, over.hom_mk_left, prod.lift_map, prod.lift_fst] },
    { rw [over.comp_left, over.comp_left, over.hom_mk_left, assoc, prod.lift_snd, ‚Üê assoc,
          ‚Üê over.comp_left, limits.prod.map_snd, comp_id, over.hom_mk_left, over.hom_mk_left,
          prod.lift_map, comp_id, prod.lift_snd] } },

  have b_pb := pullback_square_iso _ _ _ _ bottom_comm,
  have right‚ÇÅ_comm : ùüô (B ‚®Ø _) ‚â´ limits.prod.map (ùüô _) (mem A) = (star_power A B ‚â´ (the_iso A ((star B).obj (P A))).hom).left ‚â´ (prod.associator B (P A) A).hom,
    apply seven_eleven_r_comm,
  have r‚ÇÅ_pb := pullback_square_iso' _ _ _ _ right‚ÇÅ_comm,
  have r‚ÇÇ_pb := pullback_prod' (mem A) B,
  have r_pb := (left_pb_to_both_pb _ _ _ _ _ _ _ _ _ r‚ÇÅ_pb) r‚ÇÇ_pb,
  have p : limits.prod.map (prod.lift g.hom k) (ùüô A) ‚â´ (prod.associator B (P A) A).hom ‚â´ limits.prod.snd = limits.prod.map k (ùüô A),
    rw [prod.associator_hom, prod.lift_snd],
    apply prod.hom_ext,
    { rw [assoc, prod.lift_fst, limits.prod.map_fst, prod.map_fst_assoc, prod.lift_snd] },
    { rw [assoc, prod.lift_snd, limits.prod.map_snd, limits.prod.map_snd] },
  refine ‚ü®_, _, subsingleton.elim _ _, subsingleton.elim _ _‚ü©,
  { intro q,
    refine cut_hpb_up _ _ _ _ _ _ _ _ b_pb,
    apply over_forget_reflects_hpb,
    refine right_both_hpb_to_left_hpb _ _ _ (has_pullback_top_of_is_pb r_pb),
    convert q },
  { intro q,
    have := stretch_hpb_down _ _ _ _ _ _ q _ b_pb,
    have := over_forget_preserves_hpb _ _ _ this,
    change has_pullback_top _ _ _,
    have p' := p.symm,
    convert left_hpb_right_pb_to_both_hpb _ _ _ _ _ _ this _ r_pb }
end

def seven_eleven (A B : C) [has_power_object.{v} A] : is_power_object (star_power A B) :=
{ hat := Œª g r m hm, by exactI over.hom_mk (prod.lift g.hom (hat (m ‚â´ (the_iso A g).hom).left)) (limit.lift_œÄ _ _),
  powerises' := Œª g r m hm, by exactI
  begin
    apply (seven_eleven_aux A B g r m (hat (m ‚â´ (the_iso A g).hom).left)).hom,
    exact hat_powerises (m ‚â´ (the_iso A g).hom).left,
  end,
  uniquely' := Œª g r m hm hat' pow, by exactI
  begin
    ext,
    rw [over.hom_mk_left, prod.lift_fst, ‚Üê over.w hat'], refl,
    rw [over.hom_mk_left, prod.lift_snd],
    apply unique_hat,
    apply (seven_eleven_aux A B g r m (hat'.left ‚â´ limits.prod.snd)).inv,
    convert pow,
    rw [star_hat],
    ext,
    rw [over.hom_mk_left, prod.lift_fst, ‚Üê over.w hat'], refl,
    rw [over.hom_mk_left, prod.lift_snd]
  end }

def logical_star [has_power_objects.{v} C] (B : C) : P_functor ‚ãô star B ‚âÖ (star B).op ‚ãô P_functor :=
begin
  apply nat_iso.of_components _ _,
  intro A,
  exact P_unique_up_to_iso (seven_eleven A.unop B) (power_is_power _),
  intros X Y g,
  haveI := adjunction.right_adjoint_preserves_limits (forget_adj_star B),
  apply comp_natural' (star B) infer_instance X.unop Y.unop g.unop,
end

local attribute [instance] has_finite_products_of_has_finite_limits

def cc_of_pow [has_power_objects.{v} C] : cartesian_closed.{v} C :=
{ closed := Œª B,
  begin
    haveI : is_right_adjoint (star B) := ‚ü®over.forget, forget_adj_star B‚ü©,
    haveI := monad.adjoint_lifting (logical_star B).symm (Œª f g X Y r, by apply_instance),
    refine exponentiable_of_star_is_left_adj B _,
    apply left_adjoint_of_right_adjoint_op,
  end }

def lcc_of_pow [has_power_objects.{v} C] : is_locally_cartesian_closed.{v} C :=
{ overs_cc := Œª B, cc_of_pow }

def subobj_hat {A B R : C} [exponentiable A] [has_subobject_classifier.{v} C] (m : R ‚ü∂ B ‚®Ø A) [mono m] :
  B ‚ü∂ A ‚üπ classifier.Œ© C :=
cartesian_closed.curry ((limits.prod.braiding _ _).inv ‚â´ classifier.classifier_of m)

def power_of_subobj (A : C) [exponentiable A] [has_subobject_classifier.{v} C] : has_power_object.{v} A :=
{ PA := A ‚üπ classifier.Œ© C,
  niA := pullback (classifier.truth C) ((limits.prod.braiding _ _).hom ‚â´ (ev A).app _),
  memA := pullback.snd,
  is_power :=
  { hat := Œª B R m hm, by exactI subobj_hat m,
    powerises' := Œª B R m hm,
    begin
      haveI := hm,
      apply right_both_hpb_to_left_hpb _ _ _ has_pullback_top_of_pb,
      erw [braid_natural_assoc, subobj_hat, curry_eq, prod_map_id_comp, assoc, (ev _).naturality,
           ev_coev_assoc, iso.hom_inv_id_assoc],
      apply classifier.classifies m,
    end,
    uniquely' := Œª B R m hm hat' p,
    begin
      rw [subobj_hat, curry_eq_iff, iso.inv_comp_eq],
      apply classifier.uniquely,
      change has_pullback_top _ _ _,
      rw [uncurry_eq, ‚Üê braid_natural_assoc],
      apply left_right_hpb_to_both_hpb pullback.snd p has_pullback_top_of_pb,
    end } }

instance topos_has_power [has_subobject_classifier.{v} C] [cartesian_closed.{v} C] : has_power_objects.{v} C :=
‚ü®Œª A, power_of_subobj A‚ü©

instance topos_has_some_colims (J : Type v) [small_category J] [has_subobject_classifier.{v} C] [cartesian_closed.{v} C] [has_limits_of_shape J·µí·µñ C] :
  has_colimits_of_shape J C :=
some_colims J

instance topos_has_finite_colimits [has_subobject_classifier.{v} C] [cartesian_closed.{v} C] : has_finite_colimits.{v} C :=
Œª _ _ _, by {resetI, apply_instance}

instance topos_is_lcc [has_subobject_classifier.{v} C] [cartesian_closed.{v} C] : is_locally_cartesian_closed.{v} C :=
lcc_of_pow

end category_theory